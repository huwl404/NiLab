nc: 2 # 2 class
backbone:
    # [from, repeats, module, args]
    - [-1, 1, Conv, [64, 3, 2]] # 0, P1, 2X downsample, after this, (1, 3, 4096, 4096) -> (1, 64, 2048, 2048)
    - [-1, 1, Conv, [128, 3, 2]] # 1, P2, 4X downsample, after this, (1, 64, 2048, 2048) -> (1, 128, 1024, 1024)
    - [-1, 3, C2f, [128, True]] # 2 P2 features: 128 X 1024 X 1024, Double Membrane precision!
    - [-1, 1, Conv, [256, 3, 2]] # 3, P3, 8X downsample, after this, (1, 128, 1024, 1024) -> (1, 256, 512, 512)
    - [-1, 6, C2f, [256, True]] # 4 P3 features: 256 X 512 X 512
    - [-1, 1, Conv, [512, 3, 2]] # 5, P4, 16X downsample, after this, (1, 256, 512, 512) -> (1, 512, 256, 256)
    - [-1, 6, C2f, [512, True]] # 6 P4 features: 512 X 256 X 256
    - [-1, 1, SPPF, [512, 5]] # 7 [out_ch, kernel_size] This module is equivalent to SPP(k=(5, 9, 13)).
    - [ -1, 1, nn.AdaptiveAvgPool2d, [ 1 ] ] # 8

head:
    - [7, 1, nn.Upsample, [None, 2, nearest]] # 9 -> 512 X 512 X 512 nn.Upsample 是标准 PyTorch 模块，不接受列表输入
    - [[-1, 4], 1, Concat, [1]] # 10 512 X 512 X 512 + 256 X 512 X 512
    - [-1, 3, C2f, [512]] # 11 -> 512 X 512 X 512
    - [ -1, 1, nn.AdaptiveAvgPool2d, [ 1 ] ] # 12

    - [10, 1, nn.Upsample, [None, 2, nearest]] # 13 -> 512 X 1024 X 1024
    - [[-1, 2], 1, Concat, [1]] # 14 512 X 1024 X 1024 + 128 X 1024 X 1024
    - [-1, 3, C2f, [256]] # 15
    - [ -1, 1, nn.AdaptiveAvgPool2d, [ 1 ] ] # 16

    - [[8, 12, 16], 1, Concat, [1]] # 17: nn.AdaptiveAvgPool2d 不能直接收三个输入，先把三个 Pool 结果拼起来
    - [-1, 1, nn.AdaptiveAvgPool2d, [1]] # 18: Applies a 2D adaptive average pooling over an input signal composed of several input planes. The output is of size H x W, for any input size.
    - [-1, 1, Classify, [nc]] # 19 [nc, anchors, ch]
# model summary: 132 layers, 20,503,362 parameters, 20,503,362 gradients, 208.1 GFLOPs